///! 790. Domino and Tromino Tiling
///! https://leetcode.com/problems/domino-and-tromino-tiling/
use crate::Problem;
pub struct Solution;
impl Problem for Solution {
    const TITLE: &'static str = "å¤šç±³è¯ºå’Œæ‰˜ç±³è¯ºå¹³é“º (Domino and Tromino Tiling)";
    fn run() {
        let n = 30;
        let result = Solution::num_tilings(n);
        println!("790 => {}", result);
    }
}

impl Solution {
    /// ä½ æ­£åœ¨åšä¸€ä¸ªå¹³é“ºæ¸¸æˆï¼Œæ¸¸æˆæ¿çš„å®½åº¦ä¸º 2ï¼Œé•¿åº¦ä¸º n ã€‚
    /// ä½ æœ‰ä¸‰ç§ä¸åŒå½¢çŠ¶çš„ç“·ç –ï¼š
    /// - 2 x 1 çš„å¤šç±³è¯ºç“·ç –ã€‚
    /// - "L" å½¢çš„å¤šç±³è¯ºç“·ç –ã€‚
    /// è®¡ç®—æœ‰å¤šå°‘ç§æ–¹æ³•å¯ä»¥å¹³é“ºè¿™ä¸ª 2 x n çš„æ¸¸æˆæ¿ã€‚è¿”å›žå¯¹ (10^9 + 7) å–æ¨¡çš„ç»“æžœã€‚
    pub fn num_tilings(n: i32) -> i32 {
        //* è¿™ä¸ªé—®é¢˜æˆ‘å¤§ä¸€æ•°æ®ç»“æž„è¯¾è®¾åšè¿‡ç±»ä¼¼çš„â€œé“ºåœ°ç –â€é—®é¢˜ï¼Œè¦ä½¿ç”¨åŠ¨æ€è§„åˆ’
        //* æ³¨ï¼šå¤§ä¸€åšçš„é‚£é¢˜æ›´éš¾ä¸€ç‚¹ ðŸ˜œ
        // dp[i]è¡¨ç¤ºé“ºæ»¡ 2 x i çš„æ–¹æ¡ˆæ•°
        // åˆ—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
        // å¦‚æžœæœ€åŽä¸€åˆ—æ˜¯ç«–ç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢æœ‰ dp[i-1] ç§é“ºæ³•
        // å¦‚æžœæœ€åŽä¸€åˆ—æ˜¯æ¨ªç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢ä¸€åˆ—ä¹Ÿå¿…é¡»æ˜¯æ¨ªç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢æœ‰ dp[i-2] ç§é“ºæ³•
        // å¦‚æžœæœ€åŽä¸€åˆ—æ˜¯ "L" å½¢çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢ä¸€åˆ—å¯ä»¥æ˜¯ç«–ç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œæˆ–è€…æ˜¯æ¨ªç€æ”¾çš„å¤šç±³è¯ºç“·ç –
        // å¦‚æžœå‰é¢ä¸€åˆ—æ˜¯ç«–ç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢æœ‰ dp[i-3] ç§é“ºæ³•
        // å¦‚æžœå‰é¢ä¸€åˆ—æ˜¯æ¨ªç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢ä¸¤åˆ—ä¹Ÿå¿…é¡»æ˜¯æ¨ªç€æ”¾çš„å¤šç±³è¯ºç“·ç –ï¼Œåˆ™å‰é¢æœ‰ dp[i-4] ç§é“ºæ³•
        // ä»¥æ­¤ç±»æŽ¨
        // dp[i] = dp[i-1] + dp[i-2] + 2*(dp[i-3] + ... + dp[1])
        // åˆ™ï¼š
        // dp[i-1] = dp[i-2] + dp[i-3] + 2*(dp[i-4] + ... + dp[1])
        // ä¸¤å¼ç›¸å‡å¾—ï¼š
        // dp[i] = 2*dp[i-1] + dp[i-3]
        // è¿™æ ·å°±å¯ä»¥ç”¨ O(n) çš„æ—¶é—´å¤æ‚åº¦å’Œ O(1) çš„ç©ºé—´å¤æ‚åº¦è§£å†³é—®é¢˜
        // dp[1] = 1, dp[2] = 2, dp[3] = 5
        const MOD: i64 = 1_000_000_007;
        match n {
            1 => 1,
            2 => 2,
            3 => 5,
            _ => {
                let mut dp: [i64; 3] = [1, 2, 5];
                for _ in 4..=n {
                    let next = (2 * dp[2] + dp[0]) % MOD;
                    dp[0] = dp[1];
                    dp[1] = dp[2];
                    dp[2] = next;
                }
                (dp[2] % MOD) as i32
            }
        }
    }
}
